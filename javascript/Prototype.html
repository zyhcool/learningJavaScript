<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        window.onload = () => {
            /*
            * ========================================================
            *   对象字面量创建对象   
            * ========================================================*/
            console.log("=============对象字面量创建对象======");
            let person = new Object();
            person = {
                name: "zyh",
                age: 19,
                // sayHi: ()=>{
                //     console.log(this.name + "say hi to you!");
                // },
                sayHi: function () {
                    console.log(this.name + " say hi to you!"); // 箭头函数的作用域改变？
                }
            }
            person.sayHi();

            person.name = "haha";
            console.log("expect haha, and the truth is " + person.name);

            Object.defineProperty(person, "name", {
                writable: false,
                value: "cool",
            })
            console.log("---after re-defineProperty of person---");
            console.log(person.name);
            person.name = "xixi";
            console.log("will person.name become 'xixi'? the person name is " + person.name);

            let book = {
                _year: 2018,
                edition: 1,
            }

            Object.defineProperty(book, "year", {
                get: function () {
                    return this._year;
                },
                set: function (value) {
                    if (!isNaN(value) && value > this._year) {
                        this.edition += value - this._year;
                        this._year = value;
                    }
                }
            });
            book.year = 2019;
            console.log("book _year: " + book._year + ";book year: " + book.year + ";book edition: " + book.edition);

            let book1 = {
                _year: 2018,
                edition: 1,
                year: {
                    get: function () {
                        return this._year;
                    },
                    set: function (value) {
                        if (!isNaN(value) && value > this._year) {
                            this.edition += value - this._year;
                            this._year = value;
                        }
                    }
                },
            };
            book1.year = 2020;
            console.log("book1 _year: " + book1._year + ";book1 year: " + book1.year + ";book1 edition: " + book1.edition);
            // 显然 book1 的构造访问器属性的方法不可行

            let book2 = {}
            Object.defineProperties(book2, {
                _year: {
                    value: 2018,
                },
                edition: {
                    value: 1,
                },
                year: {
                    get: function () {
                        return this._year;
                    },
                    set: function (value) {
                        if (!isNaN(value) && value > this._year) {
                            this.edition += value - this._year;
                            this._year = value;
                        }
                    }
                },
            });
            book2.year = 2021;
            console.log("book2 _year: " + book2._year + ";book2 year: " + book2.year + ";book2 edition: " + book2.edition);
            // 为什么这个也不行。。。。

            /*
            * ========================================================
            *   创建对象之 -- 工厂模式   (使用函数封装创建对象的过程而已，跟上例创建对象本质一样)
            * ========================================================*/
            console.log("=============工厂模式======");
            let createPerson = function (name, age) {
                let person = new Object();
                person = {
                    name,
                    age,
                    sayName: function () {
                        console.log("My name is " + this.name);
                    },
                };
                return person;
            }
            let xiaoming = createPerson("xiaoming", 12);
            console.log("xiaoming's name is " + xiaoming.name);
            console.log("xiaoming's age is " + xiaoming.age);
            xiaoming.sayName();

            /*
            * ========================================================
            *   创建对象之 -- 构造函数模式   (本身也是函数，只是使用 new 可以构造对象)
            * ========================================================*/
            console.log("=============构造函数模式======");
            function Person(name, age) {
                this.name = name;
                this.age = age;
                this.sayName = function () {
                    console.log("My name is " + this.name);
                };
            };
            let xiaohong = new Person("xiaohong", 23);
            console.log("xiaohong's name: " + xiaohong.name + ";xiaohong's age: " + xiaohong.age);
            xiaohong.sayName();

            /*
            * ========================================================
            *   创建对象之 -- 原型模式   （共享属性和方法）
            * ========================================================*/
            console.log("=============原型模式======");
            console.log(Person.prototype); // 结果为 Person.prototype == { constructor: Person(name,age) }
            function Person1() { };
            Person1.prototype.name = "zyh";
            Person1.prototype.age = 19;
            Person1.prototype.sayName = function () {
                console.log("My name is " + this.name);
            }
            console.log("Person1.prototype: " + Person1.prototype);
            let zyh = new Person1();
            zyh.name = "cool";
            zyh.sayName();
            console.log(Person1.prototype.isPrototypeOf(zyh));

            console.log(Object.getPrototypeOf(zyh));
            // 原型对象的之不会被重写
            let cool = new Person1();
            cool.name = "cool";
            console.log("cool'name: " + cool.name);
            console.log("Person1.prototype.name: " + Person1.prototype.name);

            // hasOwnProperty
            console.log(cool.hasOwnProperty("name"));
            console.log(Person1.prototype.hasOwnProperty("name"));

            delete cool.name;
            console.log(cool.hasOwnProperty("name"));

            // in 操作符可以遍历实例属性和原型属性
            function hasPrototypeProperty(obj, key) {
                return !obj.hasOwnProperty(key) && (key in obj);
            }
            console.log("age是否是Person1原型对象的属性：" + hasPrototypeProperty(zyh, "age"));

            // Object.keys() 只遍历实例所有可枚举属性
            console.log("zyh's keys: " + Object.keys(zyh));

            // getOwnPropertyNames() 获得所有属性（包括不可枚举属性）
            console.log("zyh's keys: " + Object.getOwnPropertyNames(zyh));

            // 
            let Person2 = function(){};
            Person2.prototype = {
                name: "haha",
                age: 33,
                job: "developer",
                sayHi: function(){
                    console.log(this.name+" say hi! ");
                }
            }
            console.log("Person1.prototype.constructor: "); // expect output: undefined;
            console.log(Person1.prototype.constructor); // expect output: undefined;
            console.log("Person2.prototype.constructor: "); // expect output: undefined;
            console.log(Person2.prototype.constructor); // expect output: undefined;
            let person2 = new Person2();
            console.log("person2.constructor: ");
            console.log(person2.constructor);

            // 原型模式的构造方法
            let Test = function(){}; //   <<====== 构造函数
            Test.prototype = { //   <<===== 原型（对象）
                name: "",
                type: "",
                dosomething: function(){
                    console.log("I don't know ! I'm just tester !");
                }
            }
            Object.defineProperty(Test.prototype,"constructor",{
                enumerable: false,
                value: Test,
            });
            let test = new Test();
            test.dosomething(); // 实例中的指针仅指向原型，而不指向指针

            /*
            * ========================================================
            *   创建对象之 组合使用构造模式和原型模式   
            * ========================================================*/
            console.log("=========组合使用构造模式和原型模式=====")
            /*
            * ========================================================
            *   构造函数模式用来构造实例属性，原型模式用来定义共享方法和属性   
            * ========================================================*/
            let Animal = function(name,type,weight,sound){
                this.name = name;
                this.type = type;
                this.weight = weight;
                this.sound = sound;
            }

            Animal.prototype = {
                constructor : Animal,
                say: function(){
                    console.log(this.sound);
                }
            }

            let cat = new Animal("helloKitty","cat",12,"meo~");
            console.log(cat);

            console.log(Animal.prototype);

            /*
            * ========================================================
            *   寄生构造函数模式   
            * ========================================================*/
            // 使用该模式为数组操作添加新的方法
            let MyArray = function(){
                let arr = new Array();
                console.log(arguments);
                arr.push.apply(arr,arguments);
                arr.sum = function(){
                    console.log(this);
                    return this.reduce((s,v)=>{
                        return s+v;
                    },0)
                }
                return arr;
            }

            let testArr = new MyArray(2,5,7);
            let sum = testArr.sum();
            console.log(sum);

            /*
            * ========================================================
            *   继承  原型链   
            * ========================================================*/
            console.log("继承 原型链");
            let SuperType = function(){
                this.name = "superType";
                this.sayName = function(){
                    console.log("I'm SuperType , my name is supertype.");
                }
            }

            let SubType = function(){
                this.name = "subType";
            }

            SubType.prototype = new SuperType();

            let subTypeInstance = new SubType();
            console.log(subTypeInstance.name)
















        }    
    </script>
</body>

</html>